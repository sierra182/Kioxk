@inject IJSRuntime js
@inject HttpClient Http
@using Kioxk.Shared.Models
@using Kioxk.Client.Shared

<div id="calendar">
    <Calendar @bind-DateTime="@DateTime" @bind-UnSelectable="@UnSelectable" @bind-Selected="@Selected" @bind-Seasons="@Seasons" />
</div>

@{
    if (periodes.Count > 0)
    {
        mycallbool = true;
        classe = "mycallplein";
    }
    else if (mycallbool)
    {
        classe = "mycallvide";
    }
}

<div tabindex="0" style="--triremplnext:@trnu;--triremplback:@trbu; --mycall-height:@mclhu;">
    <svg @onclick="OnBack"
         data-src="/svg/tri.svg"
         id="mytriback"
         data-js="enabled"
         data-unique-ids="disabled"
         style="visibility:@visBack">
    </svg>

    <svg @onclick="OnNext"
         data-src="/svg/tri.svg"
         id="mytrinext"
         data-js="enabled"
         data-unique-ids="disabled"
         style="visibility: @visNext">
    </svg>

    <div>
        <svg @onclick="OnClearAll"
             class="@classe"
             data-src="/svg/call.svg"
             id="mycall"
             data-js="enabled"
             data-unique-ids="disabled">
        </svg>

    </div>
</div>

<div id="periodes">
    <Periodes @bind-Selected="@Selected" @bind-Seasons="@Seasons" @bind-Prices="@Prices" @bind-periodes="@periodes" />
</div>


@code {

    public HashSet<DateTime> sel = new();
    [Parameter]
    public HashSet<DateTime> Selected { get { return sel; } set { if (!sel.SetEquals(value)) { SelectedChanged.InvokeAsync(value); } sel = new(value); } }
    [Parameter]
    public EventCallback<HashSet<DateTime>> SelectedChanged { get; set; }
    [Parameter]
    public HashSet<DateTime>[] Seasons { get; set; }
    [Parameter]
    public EventCallback<HashSet<DateTime>[]> SeasonsChanged { get; set; }
    [Parameter]
    public int[] Prices { get; set; }
    [Parameter]
    public EventCallback<int[]> PricesChanged { get; set; }

    private List<List<DateTime>> periodes { get; set; } = new();
    private DateTime DateTime { get; set; } = DateTime.Now;
    private HashSet<DateTime> UnSelectable { get; set; } = new();

    private int trn;
    private string trnu = "0%";
    private int trb;
    private string trbu = "0%";
    private string mclhu = "0%";
    private string classe = "";
    private bool mycallbool = false;

    private string visBack = "Hidden";
    private string visNext = "Visible";
    private DateTime now = DateTime.Now;

    async Task Sync()
    {
        while (true)
        {
            var exSeasons = new HashSet<DateTime>[] { new(Seasons[0]), new(Seasons[1]) };        // Comparateur Saisons Updated
            var exPrices = Prices.ToList();
            var livret = await Http.GetFromJsonAsync<Livret>("api/commande");
            if (livret is not null)
            { installLivret(livret); }

            afterSync(exSeasons, exPrices);
            StateHasChanged();

            await Task.Delay(5000);
        }
    }

    void afterSync(HashSet<DateTime>[] seas, List<int> pric)
    {
        var intersec = new HashSet<DateTime>(Selected);
        intersec.IntersectWith(UnSelectable);
        if (intersec.Count > 0)
        {

            foreach (var i in intersec)
            {
                Selected.Remove(i);
            }
            js.InvokeVoidAsync("alert", "Attention une période que vous avez selectionnée n'est désormais plus disponible, et a été supprimé de votre selection. Veuillez re-vérifier vos date svp.");
        }

        var unionExSais = new HashSet<DateTime>(seas[0]);         //  Réunis les anciennes saisons dans le meme HashSet
        unionExSais.UnionWith(seas[1]);
        var unionSais = new HashSet<DateTime>(Seasons[0]);        //  Réunis les nouvelless saisons dans le meme HashSet
        unionSais.UnionWith(Seasons[1]);

        var intersecExSais = new HashSet<DateTime>(Selected);     // Calcule si parmis les anciennes saisons, une date correspond à la selection.
        intersecExSais.IntersectWith(unionExSais);
        var intersecSais = new HashSet<DateTime>(Selected);       // Calcule si parmis les nouvelles saisons, une date correspond à la selection.
        intersecSais.IntersectWith(unionSais);

        // Si les anciennes saisons ne correspondent plus aux nouvelles et qu'aucune selection ne fait partie des anciennes ou noouvelles saisons.
        if ((!seas[0].SetEquals(Seasons[0]) || !seas[1].SetEquals(Seasons[1])) && (intersecExSais.Count > 0 || intersecSais.Count > 0))
        {
            js.InvokeVoidAsync("alert", "Attention la synchronisation indique que les dates des saisons ont été modifiées depuis le serveur, à l'instant. Veuillez vérifier votre commande.");
        }

        pric.Remove(pric.ElementAt(0));             // Enlève le prix total aux anciens prix.
        var npric = Prices.ToList();                // Crée une nouvelle liste des prix udpdated.
        npric.Remove(npric.ElementAt(0));           // Y enlève le prix Total

        if (!pric.SequenceEqual(npric) && Selected.Count > 0)  // Si les prix ont changés et qu'il y a au moins une selection.
        {
            js.InvokeVoidAsync("alert", "Attention la synchronisation indique que les prix ont potentiellement été modifiés. Veuillez re-vérifier votre commande.");
        }
    }

    void installLivret(Livret livret)
    {
        UnSelectable = new();                                                                     // Convertis les entitées en Objet.
        foreach (var dt in livret.UnSelectable)                                                   // Installe Unselectable.
        {
            UnSelectable.Add(dt.dt);
        }

        for (int prevDay = now.Day; prevDay >= 1; prevDay--)                                      // Rend non-selectable les jours précédents le jour actuel.
        {
            UnSelectable.Add(new DateTime(now.Year, now.Month, prevDay));
        }

        CompleteWeek();

        Seasons[1] = new();
        Seasons[0] = new();
        var i = 0;
        foreach (var Hs in livret.Seasons)                                              // Installe les saisons.
        {
            foreach (var dt in Hs.Hs)
            {
                Seasons[i].Add(dt.dt);
            }
            i++;
        }
        foreach (var f in Seasons[1].ToList())                                          // Rend les moyennes et hautes saisons annuelles.
        {
            Seasons[1].Add(new DateTime(now.Year, f.Month, f.Day));
            Seasons[1].Add(new DateTime(now.Year + 1, f.Month, f.Day));
            Seasons[1].Remove(f);
        }

        foreach (var f in Seasons[0].ToList())
        {
            Seasons[0].Add(new DateTime(now.Year, f.Month, f.Day));
            Seasons[0].Add(new DateTime(now.Year + 1, f.Month, f.Day));
            Seasons[0].Remove(f);
        }

        var j = 1;
        foreach (var it in livret.Prices)                                              // Installe les prix.
        {
            Prices[j] = it.it;
            j++;
        }
    }

    protected override void OnInitialized()
    {
        Console.WriteLine("prouteer");
        _ = Task.Run(() => { _ = Sync(); });

    }

    void CompleteWeek()
    {                                                                           // Rend non-selectable les derniers jours de la semaine actuelle.
        int j = (Int32)now.DayOfWeek;
        DateTime ntime = now.Date;
        while (j != 0)
        {
            ntime = ntime.AddDays(1);
            UnSelectable.Add(ntime);
            j = (Int32)ntime.DayOfWeek;
        }
    }

    const int maxMonth = 12;
    int maxNext;

    void OnNext()
    {                                                                           // Limite à maintenant jusqu'aux douze prochains mois: Aller
        visBack = "Visible";
        if (maxNext < maxMonth)
        {
            DateTime = DateTime.AddMonths(1);
            maxNext++;

            if (maxNext == maxMonth)
            {
                visNext = "Hidden";
            }

            TriRempl();
        }
    }

    int offset = 20;
    void OnBack()
    {                                                                           // Limite à maintenant jusqu'aux douze prochains mois: Retour
        visNext = "Visible";

        if (maxNext > 0)
        {
            DateTime = DateTime.AddMonths(-1);
            maxNext--;

            if (maxNext == 0)
            {
                visBack = "Hidden";
            }

            TriRempl();
        }
    }

    void TriRempl()                                                              // Remplissage Back Next.
    {
        trn = 100 / 17 * maxNext + offset;
        trnu = trn + "%";
        trb = 100 - (100 / 17 * maxNext + offset);
        trbu = trn + "%";
    }

    void OnClearAll()
    {
        Selected.Clear();
        SelectedChanged.InvokeAsync(Selected);
    }
}