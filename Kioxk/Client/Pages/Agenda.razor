@inject IJSRuntime js
@inject HttpClient Http
@using Kioxk.Shared.Models
@using Kioxk.Client.Shared

@*<div id="carreage" class="carre" onclick="scaler('agenda','carreage','carre2age','-25','25','25','25')">
    <div id="carre2age" class="carre2" />
</div>*@

<div id="calendar">
    <Calendar @bind-DateTime="@DateTime" @bind-UnSelectable="@UnSelectable" @bind-Selected="@Selected" @bind-Seasons="@Seasons" />
</div>
@{
    if (periodes.Count > 0)
    {
        mycallbool = true;
        classe = "mycallplein";
    }
    else if (mycallbool)
    {
        classe = "mycallvide";
    }
}
<div tabindex="0" style="--triremplnext:@trnu;--triremplback:@trbu; --mycall-height:@mclhu;">
    <svg @onclick="OnBack"
         data-src="/svg/tri.svg"
         id="mytriback"
         data-js="enabled"
         data-unique-ids="disabled"
         style="visibility:@visBack"></svg>

    <svg @onclick="OnNext"
         data-src="/svg/tri.svg"
         id="mytrinext"
         data-js="enabled"
         data-unique-ids="disabled"
         style="visibility: @visNext"></svg>
    <div>
        <svg @onclick="OnClearAll"
             class="@classe"
             data-src="/svg/call.svg"
             id="mycall"
             data-js="enabled"
             data-unique-ids="disabled"></svg>
    </div>
</div>

<div id="periodes">
    <Periodes @bind-Selected="@Selected" @bind-Seasons="@Seasons" @bind-Prices="@Prices" @bind-periodes="@periodes" />
</div>


@code {
    public HashSet<DateTime> sel = new();
    [Parameter]
    public HashSet<DateTime> Selected { get { return sel; } set { if (!sel.SetEquals(value)) { SelectedChanged.InvokeAsync(value); } sel = new(value); } }
    [Parameter]
    public EventCallback<HashSet<DateTime>> SelectedChanged { get; set; }
    [Parameter]
    public HashSet<DateTime>[] Seasons { get; set; }/* = new HashSet<DateTime>[2] { new(), new() };*/
    [Parameter]
    public EventCallback<HashSet<DateTime>[]> SeasonsChanged { get; set; }
    [Parameter]
    public int[] Prices { get; set; } /*= { 0, 80, 100, 120 };*/
    [Parameter]
    public EventCallback<int[]> PricesChanged { get; set; }

    private List<List<DateTime>> periodes { get; set; } = new();
    private DateTime DateTime { get; set; } = DateTime.Now;
    private HashSet<DateTime> UnSelectable { get; set; } = new();

    private int trn;
    private string trnu = "0%";
    private int trb;
    private string trbu = "0%";
    private string mclhu = "0%";
    private string classe = "";
    private bool mycallbool = false;

    private string visBack = "Hidden";
    private string visNext = "Visible";
    private DateTime now = DateTime.Now;

    async Task Sync()
    {
        while (true)
        {            
            var exSeasons = new HashSet<DateTime>[] { new(Seasons[0]), new(Seasons[1]) };        // Comparateur Saisons Updated
            var exPrices = Prices.ToList();
            var livret = await Http.GetFromJsonAsync<Livret>("api/commande");
            if (livret is not null)
            { installLivret(livret); }

            afterSync(exSeasons, exPrices);
            StateHasChanged();

            await Task.Delay(5000);
        }
    }


    void afterSync(HashSet<DateTime>[] seas, List<int> pric)
    {
        var intersec = new HashSet<DateTime>(Selected);
        intersec.IntersectWith(UnSelectable);
        if (intersec.Count > 0)
        {
           
            foreach (var i in intersec)
            {
                Selected.Remove(i);
            }
            js.InvokeVoidAsync("alert", "Attention une période que vous avez selectionnée n'est désormais plus disponible, et a été supprimé de votre selection. Veuillez re-vérifier vos date svp.");
        }
    
        var unionExSais = new HashSet<DateTime>(seas[0]);         //  Réunis les anciennes saisons dans le meme HashSet
        unionExSais.UnionWith(seas[1]);
        var unionSais = new HashSet<DateTime>(Seasons[0]);        //  Réunis les nouvelless saisons dans le meme HashSet
        unionSais.UnionWith(Seasons[1]);

        var intersecExSais = new HashSet<DateTime>(Selected);     // Calcule si parmis les anciennes saisons, une date correspond à la selection.
        intersecExSais.IntersectWith(unionExSais);
        var intersecSais = new HashSet<DateTime>(Selected);       // Calcule si parmis les nouvelles saisons, une date correspond à la selection.
        intersecSais.IntersectWith(unionSais);

        // Si les anciennes saisons ne correspondent plus aux nouvelles et qu'aucune selection ne fait partie des anciennes ou noouvelles saisons.
        if ((!seas[0].SetEquals(Seasons[0]) || !seas[1].SetEquals(Seasons[1])) && (intersecExSais.Count > 0 || intersecSais.Count > 0))
        {
            js.InvokeVoidAsync("alert", "Attention la synchronisation indique que les dates des saisons ont été modifiées depuis le serveur, à l'instant. Veuillez vérifier votre commande.");
        }

        pric.Remove(pric.ElementAt(0));             // Enlève le prix total aux anciens prix.
        var npric = Prices.ToList();                // Crée une nouvelle liste des prix udpdated.
        npric.Remove(npric.ElementAt(0));           // Y enlève le prix Total

        if (!pric.SequenceEqual(npric) && Selected.Count > 0)  // Si les prix ont changés et qu'il y a au moins une selection.
        {
            js.InvokeVoidAsync("alert", "Attention la synchronisation indique que les prix ont potentiellement été modifiés. Veuillez re-vérifier votre commande.");
        }
    }

    //bool t;
    //void toggle()
    //{
    //    if (!t)
    //    {
    //        Remplissage();
    //        t = !t;
    //    }
    //    else
    //    {
    //        deRemplissage();
    //        t = !t;
    //    }
    //}

    //void deRemplissage()
    //{
    //    UnSelectable.Clear();
    //    //Selected.Clear();
    //    Seasons[0].Clear();
    //    Seasons[1].Clear();
    //}

    //void Remplissage()
    //{
    //    for (int i = 2; i < 22; i++)
    //    {
    //        UnSelectableTab.Add(new DateTime(2021, 9, i));
    //    }

    //    for (int i = now.Day; i >= 1; i--)                                      // Rend non-selectable les jours précédents le jour actuel.
    //    {
    //        UnSelectableTab.Add(new DateTime(now.Year, now.Month, i));
    //    }

    //    CompleteWeek();
    //    UnSelectable = new(UnSelectableTab);

    //    Seasons[1] = new();                                                             // Provisoire
    //    for (int i = 1; i < 10; i++)
    //    {
    //        Seasons[1].Add(new DateTime(2000, 12, i));
    //    }
    //    for (int i = 8; i < 11; i++)
    //    {
    //        Seasons[1].Add(new DateTime(2000, 9, i));
    //    }

    //    Seasons[0] = new();
    //    for (int i = 1; i < 10; i++)
    //    {
    //        Seasons[0].Add(new DateTime(2000, 10, i));
    //    }
    //    for (int i = 19; i < 26; i++)
    //    {
    //        Seasons[1].Add(new DateTime(2000, 2, i));
    //    }

    //    foreach (var f in Seasons[1].ToList())                                          // Rend les moyennes et hautes périodes annuelle
    //    {
    //        Seasons[1].Add(new DateTime(now.Year, f.Month, f.Day));
    //        Seasons[1].Add(new DateTime(now.Year + 1, f.Month, f.Day));
    //        Seasons[1].Remove(f);
    //    }
    //    foreach (var f in Seasons[0].ToList())
    //    {
    //        Seasons[0].Add(new DateTime(now.Year, f.Month, f.Day));
    //        Seasons[0].Add(new DateTime(now.Year + 1, f.Month, f.Day));
    //        Seasons[0].Remove(f);
    //    }
    //}

    void installLivret(Livret livret)
    {
        UnSelectable = new();                                                                     // Convertis les entitées en Objet.
        foreach (var dt in livret.UnSelectable)                                                   // Installe Unselectable.
        {
            UnSelectable.Add(dt.dt);
        }

        for (int prevDay = now.Day; prevDay >= 1; prevDay--)                                      // Rend non-selectable les jours précédents le jour actuel.
        {
            UnSelectable.Add(new DateTime(now.Year, now.Month, prevDay));
        }

        CompleteWeek();

        Seasons[1] = new();
        Seasons[0] = new();
        var i = 0;
        foreach (var Hs in livret.Seasons)                                              // Installe les saisons.
        {
            foreach (var dt in Hs.Hs)
            {
                Seasons[i].Add(dt.dt);
            }
            i++;
        }
        foreach (var f in Seasons[1].ToList())                                          // Rend les moyennes et hautes saisons annuelles.
        {
            Seasons[1].Add(new DateTime(now.Year, f.Month, f.Day));
            Seasons[1].Add(new DateTime(now.Year + 1, f.Month, f.Day));
            Seasons[1].Remove(f);
        }

        foreach (var f in Seasons[0].ToList())
        {
            Seasons[0].Add(new DateTime(now.Year, f.Month, f.Day));
            Seasons[0].Add(new DateTime(now.Year + 1, f.Month, f.Day));
            Seasons[0].Remove(f);
        }

        var j = 1;
        foreach (var it in livret.Prices)                                              // Installe les prix.
        {
            Prices[j] = it.it;
            j++;
        }
    }

    protected override void OnInitialized()
    {
        Console.WriteLine("prouteer");
        _ = Task.Run( ()=>{ Sync(); });
       // _ = Sync();
    }

    void CompleteWeek()
    {                                                                           // Rend non-selectable les derniers jours de la semaine actuelle.
        int j = (Int32)now.DayOfWeek;
        DateTime ntime = now.Date;
        while (j != 0)
        {
            ntime = ntime.AddDays(1);
            UnSelectable.Add(ntime);
            j = (Int32)ntime.DayOfWeek;
        }
    }

    const int maxMonth = 12;
    int maxNext;
    void OnNext()
    {                                                                           // Limite à maintenant jusqu'aux douze prochains mois: Aller
        visBack = "Visible";
        if (maxNext < maxMonth)
        {
            DateTime = DateTime.AddMonths(1);
            maxNext++;

            if (maxNext == maxMonth)
            {
                visNext = "Hidden";
            }

            TriRempl();
        }
    }

    int offset = 20;
    void OnBack()
    {                                                                           // Limite à maintenant jusqu'aux douze prochains mois: Retour
        visNext = "Visible";

        if (maxNext > 0)
        {
            DateTime = DateTime.AddMonths(-1);
            maxNext--;

            if (maxNext == 0)
            {
                visBack = "Hidden";
            }

            TriRempl();
        }
    }

    void TriRempl()                                                              // Remplissage Back Next.
    {
        trn = 100 / 17 * maxNext + offset;
        trnu = trn + "%";
        trb = 100 - (100 / 17 * maxNext + offset);
        trbu = trn + "%";
    }

    void OnClearAll()
    {
        Selected.Clear();
        SelectedChanged.InvokeAsync(Selected);
    }
}